**Tip：排序和链表等数组结构代码在C语言基础中**。

# 1.查找

## 1.1.二分查找[O(logn)]

### 1.1.1.二分查找算法

> 二分查找简单算法

```c
#include <stdio.h>

// 二分查找(简单算法)：有序数组
int binSearch(int* a, int n, int value);

int main(int argc, char const *argv[]) {
	int a[] = {1, 2, 3, 4, 5, 6};
	int n = sizeof(a) / sizeof(a[0]);
	
	int pos = binSearch(a, n, 3);
	printf("%d\n", pos);
	
	return 0;
}

int binSearch(int* a, int n, int value) {
	int lo = 0;                           // 左侧起始指针 
	int hi = n - 1;                       // 右侧起始指针 
	
	while(lo <= hi) {                     // 临界值 
		int mid = (lo + hi) / 2;          // 取中点 
		if(a[mid] == value)               
			return mid;
		else if(a[mid] < value)           
			lo = mid + 1;
		else
			hi = mid - 1;
	}
	
	return -1;                            // 没有找到                        
}
```

**注意的问题**：

**1.循环退出条件**

注意是 low<=high，而不是 low。

**2.mid 的取值**

实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。

**3.low 和 high 的更新**

low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。



> 二分查找递归算法

```c
#include <stdio.h>

// 1.二分查找(递归算法)
int binsearch(int* a, int lo, int hi, int value);

// 2.封装二分查找
int bsearch(int* a, int n, int value);

int main(int argc, char const *argv[]) {
	int a[] = {1, 2, 3, 4, 5};
	int n = sizeof(a) / sizeof(a[0]);
	
	int pos = bsearch(a, n, 4);
	printf("%d\n", pos);
	
	return 0;
}

int binsearch(int* a, int lo, int hi, int value) {
	if(lo > hi) return -1;                        // 递归出口

    // 这里注意+ -算术运算符的优先级比移位运算优先级要高
	int mid = lo + ((hi - lo) >> 1);              // 取中点
	if(a[mid] == value)                           // 数组中点恰好是要查找的值
		return mid;
	if(a[mid] < value)                            // 要查找的值在数组右边
		return binsearch(a, mid + 1, hi, value);
	else                                          // 要查找的值在数组左边
		return binsearch(a, lo, mid - 1, value);
}

int bsearch(int* a, int n, int value) {
	binsearch(a, 0, n - 1, value);
}
```



### 1.1.2.二分查找的局限性

**首先，二分查找依赖的是顺序表结构，简单点说就是数组**。

那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。



**其次，二分查找针对的是有序数据**。

二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。**并且二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中**。



**最后，数据量太大也不适合二分查找**。

二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，**要求内存空间连续，对内存的要求比较苛刻**。注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。



### 1.1.3.二分查找的变形

![二分查找的变形](https://static001.geekbang.org/resource/image/42/36/4221d02a2e88e9053085920f13f9ce36.jpg)



## 1.2.散列表

### 1.2.1.基本构成

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表**。

![散列表](https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg)

**设计散列函数的基本要求**：

1.散列函数计算得到的散列值是一个非负整数；

2.如果 key1 = key2，那 hash(key1) == hash(key2)；

3.如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

**第三点这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的**。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

### 1.2.2.散列冲突

**散列冲突**：再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。



> 开发地址法

**开放寻址法**的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？

**线性探测(插入)**：当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

![线性探测](https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg)

从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。



**线性探测(查找)**：在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。

![线性探测查找](https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg)

散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。**我们不能单纯地把要删除的元素设置为空**。在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这个问题如何解决呢？

**我们可以将删除的元素，特殊标记为 deleted**。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。

![deleted](https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg)

线性探测法其实存在很大问题。**当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久**。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。



> 链地址发法

![链表法](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)

**当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)**。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。

那查找或删除操作的时间复杂度是多少呢？**实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)**。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

# 2.树和二叉树

## 2.1.树

**关于“树”，有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：**

![树的概念](https://static001.geekbang.org/resource/image/40/1e/4094a733986073fedb6b9d03f877d71e.jpg)

在我们的生活中，**“高度”这个概念，其实就是从下往上度量**，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。

**“深度”这个概念在生活中是从上往下度量的**，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。

**“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层**。

## 2.2.二叉树

### 2.2.1.二叉树的基本概念

![二叉树](https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg)

这个图里面，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。

其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做**满二叉树**。

编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做**完全二叉树**。

**完全二叉树一定是由满二叉树从右至左从下至上，挨个删除结点所得到的，如果跳着删除，那就不是完全二叉树**。

![完全二叉树](https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg)



### 2.2.2.二叉树的存储

想要存储一棵二叉树，我们有两种方法：

- 一种是基于指针或者引用的**二叉链式存储法**；
- 一种是基于数组的**顺序存储法**。

> 链式存储法

![链式存储法](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)

**每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针**。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。



> 顺序存储法

我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

![顺序存储](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg)

如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。**通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来**。

不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。

![非完全二叉树的顺序存储](https://static001.geekbang.org/resource/image/08/23/08bd43991561ceeb76679fbb77071223.jpg)

所以，**如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式**。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。



### 2.2.3.二叉树的遍历[O(n)]

**前序遍历、中序遍历和后序遍历**。

其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![二叉树的遍历](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg)

**实际上，二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。

```c
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

三种遍历方式的代码：

```c
void preOrder(Node* root) {
    if(root == null) return;
    print root;               // 此处为伪代码，表示打印root节点
    preOrder(root->left);
    preOrder(root->right);
}

void inOrder(Node* root) {
    if(root == null) return;
    inOrder(root->left);
    print root;               // 此处为伪代码，表示打印root节点
    inOrder(root->right);
}

void postOrder(Node* root) {
    if(root == null) return;
    preOrder(root->left);
    preOrder(root->right);
    print root;               // 此处为伪代码，表示打印root节点
}
```

从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说**二叉树遍历的时间复杂度是 O(n)**。



> 思考

**1、给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？**

如果说是完全二叉树，可以在数组中存储，那么根据高中数学排列的知识就是n!。

**2、除了前、中、后序三种遍历方式。实际上，还有另外一种遍历方式，也就是按层遍历，如何实现？**

图的广度优先遍历问题。